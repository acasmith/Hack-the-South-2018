module.exports = {
	//Contains all non-paired sockets by category.
	freeClients: {
		movies: [],
		books: [],
		music: [],
		tech: [],
		physics: [],
	},
	
	//Matches socket with first one in queue.
	//If queue is empty then adds socket to the appropriate interest queue and returns.
	findMatch: function(socket){
		console.log(socket.interest + " user queue count before matching: " + this.freeClients[socket.interest].length);
		//for each element in array, place it in interest attribute of clients container.
		if(this.freeClients[socket.interest].length < 1){
			this.freeClients[socket.interest].push(socket);
			return;
		}
		//Iterate over sockets in same interest, return first one that hasn't been partnered to socket before.
		for(var i = 0; i < this.freeClients[socket.interest].length; i++){
			if(socket.pastPartners.indexOf(this.freeClients[socket.interest][i]) < 0){
				console.log("Match found!");
				return this.freeClients[socket.interest][i];	//CHANGE TO SPLICE SO THE ENTRY IS REMOVED.
			}
		}
		//Else every other socket has been partnered so join the queue to wait.
		this.freeClients[socket.interest].push(socket);
	},
	
	setupSession: function(socket){
		socket.partner = this.findMatch(socket);
		if(socket.partner){
			//Message partner with own details and get partner details.
			console.log("setup session firing");
			socket.partner.partner = socket;
			socket.roomName = socket.id + "" + socket.partner.id;
			socket.partner.roomName = socket.roomName;
			console.log("roomName: " + socket.roomName + ", " + socket.partner.roomName);
			socket.join(socket.roomName);
			socket.partner.join(socket.roomName);
			socket.to(socket.roomName).emit("give description", socket.description);
			socket.partner.to(socket.roomName).emit("give description", socket.partner.description);
		}
	},
}